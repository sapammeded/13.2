<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Ghost LIVE â€“ i / C / C++</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
<style>
html,body{margin:0;height:100%;background:#0b1220;color:#e5e7eb;font-family:Arial,Helvetica,sans-serif}
#top{display:flex;gap:8px;align-items:center;padding:10px;background:#0f172a}
select{background:#111827;color:#e5e7eb;border:1px solid #334155;padding:6px 10px;border-radius:6px}
#status{margin-left:auto;font-weight:bold}
#chart{height:calc(100% - 50px)}
.badge{padding:2px 6px;border-radius:6px;font-size:12px}
</style>
</head>
<body>
<div id="top">
  <b>Ghost LIVE</b>
  <select id="pair"><option>BTCUSDT</option><option>ETHUSDT</option></select>
  <select id="tf">
    <option value="1m">M1</option>
    <option value="3m">M3</option>
    <option value="5m">M5</option>
    <option value="15m">M15</option>
  </select>
  <span id="status">INIT</span>
</div>
<div id="chart"></div>

<script>
/* ===================== CHART ===================== */
const container = document.getElementById('chart');
const statusEl  = document.getElementById('status');
const pairSel   = document.getElementById('pair');
const tfSel     = document.getElementById('tf');

const chart = LightweightCharts.createChart(container,{
  layout:{background:{color:'#0b1220'},textColor:'#e5e7eb'},
  grid:{vertLines:{color:'#1f2937'},horzLines:{color:'#1f2937'}},
  timeScale:{timeVisible:true,secondsVisible:false},
  rightPriceScale:{borderColor:'#334155'}
});
const realSeries = chart.addCandlestickSeries({
  upColor:'#22c55e',downColor:'#ef4444',
  wickUpColor:'#22c55e',wickDownColor:'#ef4444',borderVisible:false
});
const ghostSeries = chart.addCandlestickSeries({
  upColor:'rgba(148,163,184,.35)',downColor:'rgba(148,163,184,.35)',
  wickVisible:true,borderVisible:false
});
const gzTop = chart.addLineSeries({color:'rgba(56,189,248,.7)',lineWidth:1});
const gzBot = chart.addLineSeries({color:'rgba(56,189,248,.7)',lineWidth:1});

/* ===================== STATE ===================== */
let ws=null, candles=[], ghosts=[];
let updating=false;

/* ===================== HELPERS ===================== */
function tfSec(tf){return tf==='15m'?900:tf==='5m'?300:tf==='3m'?180:60}
function body(c){return Math.abs(c.close-c.open)}
function range(c){return Math.max(c.high-c.low,1e-9)}
function bull(c){return c.close>c.open}
function wickUp(c){return c.high - Math.max(c.open,c.close)}
function wickDn(c){return Math.min(c.open,c.close) - c.low}

/* ===================== i / C / C++ (NON-REPAINT) ===================== */
const markers=[];
function classifyICpp(){
  // gunakan 3 candle terakhir yang SUDAH CLOSE
  if(candles.length < 3) return;
  const i  = candles[candles.length-3];
  const C  = candles[candles.length-2];
  const Cp = candles[candles.length-1];

  // kriteria ringkas berbasis body+sumbu (tidak repaint)
  const i_ok  = body(i) > (wickUp(i)+wickDn(i))*0.6;
  const C_ok  = bull(C) === bull(i) || body(C) < body(i);
  const Cp_ok = body(Cp) >= body(C) && bull(Cp) === bull(i);

  if(i_ok){
    markers.push({time:i.time, position:'aboveBar', color:'#60a5fa', shape:'circle', text:'i'});
  }
  if(i_ok && C_ok){
    markers.push({time:C.time, position:'aboveBar', color:'#f59e0b', shape:'circle', text:'C'});
  }
  if(i_ok && C_ok && Cp_ok){
    markers.push({time:Cp.time, position:'aboveBar', color:'#22c55e', shape:'circle', text:'C++'});
  }
  realSeries.setMarkers(markers);
}

/* ===================== GHOST (STABLE) ===================== */
function buildGhost(base){
  const dir = bull(base);
  const r   = range(base);
  const step = tfSec(tfSel.value);
  let last = base.close;
  for(let i=1;i<=3;i++){
    const o = last;
    const c = o + (dir?1:-1)*(r*(0.35/i));
    const h = Math.max(o,c)+r*0.25;
    const l = Math.min(o,c)-r*0.25;
    ghosts.push({time:base.time+step*i,open:o,high:h,low:l,close:c});
    last = c;
  }
  ghostSeries.setData(ghosts);
  const mid = base.close;
  gzTop.setData([{time:base.time,value:mid+r*0.6},{time:base.time+step*3,value:mid+r*0.6}]);
  gzBot.setData([{time:base.time,value:mid-r*0.6},{time:base.time+step*3,value:mid-r*0.6}]);
}

/* ===================== LOAD & LIVE (HARDENED) ===================== */
async function load(){
  updating=false;
  if(ws){ try{ws.close()}catch(e){} ws=null; }
  candles=[]; ghosts.length=0; markers.length=0;
  realSeries.setData([]); ghostSeries.setData([]);
  gzTop.setData([]); gzBot.setData([]);
  realSeries.setMarkers([]);
  statusEl.textContent='LOAD';

  const pair = pairSel.value;
  const tf   = tfSel.value;

  const hist = await fetch(`https://api.binance.com/api/v3/klines?symbol=${pair}&interval=${tf}&limit=200`).then(r=>r.json());
  candles = hist.map(k=>({time:k[0]/1000,open:+k[1],high:+k[2],low:+k[3],close:+k[4]}));
  if(candles.length>=2){
    realSeries.setData(candles);
    chart.timeScale().fitContent();
  }

  ws = new WebSocket(`wss://stream.binance.com:9443/ws/${pair.toLowerCase()}@kline_${tf}`);
  ws.onopen = ()=>{ statusEl.textContent='LIVE'; updating=true; };
  ws.onmessage = (e)=>{
    if(!updating) return;
    const k = JSON.parse(e.data).k;
    if(!k.x) return; // only on close
    const c = {time:k.t/1000,open:+k.o,high:+k.h,low:+k.l,close:+k.c};
    candles.push(c);
    realSeries.update(c);
    classifyICpp();   // i / C / C++ saat CLOSE (non-repaint)
    buildGhost(c);    // ghost & zone
    if(candles.length>400) candles.shift();
  };
  ws.onerror = ()=> statusEl.textContent='WS ERR';
}

pairSel.onchange=load;
tfSel.onchange=load;
window.addEventListener('resize',()=>chart.resize(container.clientWidth,container.clientHeight));
load();
</script>
</body>
</html>